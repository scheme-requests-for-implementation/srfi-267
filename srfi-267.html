<!doctype html>
<html lang="en">
  <!--
SPDX-FileCopyrightText: 2025 Peter McGoron
SPDX-License-Identifier: MIT
-->
  <head>
    <meta charset="utf-8" />
    <title>SRFI 267: Raw String Syntax</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css" />
    <style>
      code { background-color: #dedede; }
      pre code { background-color: transparent; }
      pre { font-size: 12pt; }
      .centered { text-align: center; }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
  <h1>
    <a href="https://srfi.schemers.org/"
      ><img
        class="srfi-logo"
        src="https://srfi.schemers.org/srfi-logo.svg"
        alt="SRFI surfboard logo" /></a
    >267: Raw String Syntax
  </h1>
  <p>by Peter McGoron</p>
<h2 id="status">Status</h2>

  <p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+267+at+srfi+dotschemers+dot+org">srfi-267@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-267/">archive</a>.</p>
  <ul>
    <li>Received: 2026-01-17</li>
    <li>60-day deadline: 2026-03-18</li>
    <li>Draft #1 published: 2026-01-17</li>
  </ul>
  <h2>Abstract</h2>
  <p>
    Raw string syntax are lexical syntax for strings that do not interpret
    escapes inside of them. They are useful in cases where the string data
    has a lot of characters like <code>\</code> or <code>&quot;</code> that would otherwise have
    to be escaped. The raw string syntax in this document is derived from
    C++11's raw string literals.
  </p>
  <h2>Issues</h2>
  <ul>
    <li>
      <p>
        Are there any other characters that need to be excluded from delimiters?
      </p>
    </li>
    <li>
      <p>
        Alternative ending characters for delimiter: for instance, C++'s <code>#&quot;delim(text)delim&quot;</code>
        or maybe <code>#&quot;delim'text'delim&quot;</code>.
      </p>
    </li>
    <li>
      <p>
        Daphne Preston-Kendal's
        <a href="https://codeberg.org/dpk/presrfis/src/branch/master/docstrings.md"
          >proposal</a
        >:
        raw strings that start with <code>#&quot;</code> and end with <code>&quot;#</code>. The string
        <code>#&quot;</code> can appear in inside of the string if paired with <code>&quot;#</code> (that is, the strings
        nest like block comments). The only escape sequences are <code>\#&quot;</code> and <code>\&quot;#</code>, which
        insert the sequences after the backslash without starting a new nesting level.
        Any other sequence that starts with <code>\</code> is not an escape sequence and inserts the
        backslash.
      </p>
    </li>
    <li>
      <p>
        Are there alternative syntaxes that could be used that don't use up a <code>#</code> character?
        <a href="https://codeberg.org/scheme/r7rs/issues/32#issuecomment-8892117">Example</a>
      </p>
    </li>
  </ul>
  <h2>Rationale</h2>
  <p>
    Many programming languages have raw string syntax: to name a few,
    <a href="https://doc.rust-lang.org/reference/tokens.html#grammar-RAW_STRING_LITERAL"
      >Rust</a
    >, <a href="https://en.cppreference.com/w/cpp/language/string_literal.html">C++</a>,
    <a href="https://docs.python.org/3/reference/lexical_analysis.html#raw-strings"
      >Python</a
    >, <a href="https://go.dev/ref/spec#String_literals">Go</a>,
    <a
      href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string"
      >C#</a
    >, and
    <a href="https://ziglang.org/documentation/master/#Multiline-String-Literals">Zig</a
    >. For a more complete list of languages referenced while writing this proposal, see
    <a
      href="https://codeberg.org/scheme/r7rs/wiki/Raw-String-Literals-in-Other-Languages"
      >this wiki page</a
    >.
  </p>
  <p>
    Scheme implementations generally do not have raw string syntax. Two exceptions are
    <a
      href="https://wiki.call-cc.org/man/5/Extensions%20to%20the%20standard#multiline-string-constant"
      >CHICKEN</a
    >
    and
    <a href="https://gambitscheme.org/latest/manual/#String-syntax">Gambit</a>, which
    use
    <a href="https://www.gnu.org/software/bash/manual/bash.html#Here-Documents"
      >heredoc</a
    >
    style syntax. Both are Scheme→C compilers that require inserting C code into their
    Scheme programs. Some Scheme implementations have the ability for the programmer to extend their
    readers, so some like <a href="https://github.com/lloda/guile-raw-strings">Guile</a> have raw strings as external extensions.
    Daphne Preston-Kendal proposed a syntax for raw strings using <code>#&quot;</code> in
    <a href="https://codeberg.org/dpk/presrfis/src/branch/master/docstrings.md"
      >another document</a
    >.
  </p>
  <p>
    The matter of raw string syntax in the <i>R<sup>7</sup>RS</i>-large was discussed in
    a WG2 meeting on
    <a href="https://codeberg.org/scheme/r7rs/wiki/Minutes+2025-11-21.-"
      >November 21st, 2025</a
    >
    with no consensus. It has also been discussed on the
    <a href="https://codeberg.org/scheme/r7rs/issues/32">issue tracker</a>
    for the <i>R<sup>7</sup>RS</i>-Large process.
  </p>
  <p>
    This SRFI proposes the use of raw strings based off of C++'s syntax.
    C++'s syntax is a raw string syntax with a customizable delimiter that
    allows for the use of a wide variety of characters inside of the delimiter.
    Raw strings start
    with the sequence <code>#&quot;</code><var>X</var><code>&quot;</code> for any sequence of characters <var>X</var> that does
    not contain <code>&quot;</code>, and are terminated by <code>&quot;</code><var>X</var><code>&quot;</code> for the same <var>X</var>.
  </p>
  <p>Examples of raw strings and their equivalent regular Scheme strings:</p>
  <pre><code>#&quot;&quot;a&quot;&quot; ; =&gt; &quot;a&quot;
#&quot;&quot;\begin{document}&quot;&quot; ; =&gt; &quot;\\begin{document}&quot;
#&quot;--&quot;)&quot;)&quot;)&quot;-&quot;&quot;--&quot; ; =&gt; &quot;)\&quot;)\&quot;)-\&quot;)&quot;</code></pre>
  <p>
    Since <var>X</var> cannot contain <code>&quot;</code>, no proper substring of the
    sequence <var>X</var> can start a delimiter. This means that a raw
    string can be read in linear time without using a general searching algorithm
    like Knuth-Morris-Pratt.
  </p>
  <p>
    The use of a customizable delimiter means that extra whitespaces are not required
    before and after the string when the raw string ends with the text
    <code>&quot;&quot;</code>. When customizable delimiters with a wide variety of characters
    cannot be used (like in
    <a href="https://spec.commonmark.org/0.31.2/#code-spans">Markdown</a>), some strings
    require spaces after the left delimiter and before the right delimiter: For example,
    <code>`` `markdown code spans containing code spans` ``</code>. With this proposal,
    a raw string using a well-chosen delimiter will require no modification to the contents
    of the string.
  </p>
  <p>
    A customizable delimiter can also be used for documentation of the
    inside of the raw string itself. For instance, SQL syntax can use
    a delimiter that starts with <code>sql</code>, LaTeX syntax can use a delimiter
    that starts with <code>latex</code>. A text editor could then switch its syntax
    highlighting within the raw string.
  </p>
  <p>
    C++ style strings have the benefit that they are convenient for inline raw
    strings and multi-line raw strings, unlike heredoc-style syntax, which
    is cumbersome for single line raw strings.
  </p>
  <p>
    Some languages, like C#, have special whitespace handling for raw strings.
    Others, like Rust and C++, do not.
    This SRFI does not handle leading, trailing, or indentation whitespace in
    any special way: they are all preserved in the resultant string. This is
    the least surprising option, and further string processing can be done
    by the programmer.
  </p>
  <p>
    Some &quot;raw&quot; string syntaxes allow for interpolation, or have different
    types of escape sequences. This proposal does not include any support
    for interpolation. (String interpolation in Scheme is the
    subject of <a href="https://srfi.schemers.org/srfi-109">SRFI 109</a>.) Interpolation makes string processing much more
    complicated and is not extensible, while also not making the strings
    truly &quot;raw.&quot; Interpolation of strings in Scheme is better accomplished by
    <code>syntax-case</code> macros.
  </p>
  <p>
    Equivalent syntax for string notated bytevectors in
    <a href="https://srfi.schemers.org/srfi-207">SRFI 207</a> or for
    vertical-bar identifiers is not included.
  </p>
  <h2>Specification</h2>
  <p>
    The grammar of raw strings is not context free. The following
    grammar describes the creation of a raw string literal for any valid
    delimiter <var>X</var>:
  </p>
  <div class="centered">
    <p>
      <var>⟨raw string (X)⟩</var> ⩴ <code>#&quot;</code> <var>X</var> <code>&quot;</code>
      <var>⟨raw string internal (X)⟩</var> <code>&quot;</code> <var>X</var>
      <code>&quot;</code>
    </p>
    <p>
      <var>⟨raw string internal (X)⟩</var> ⩴ Any sequence of zero or more characters that does not contain
      <code>&quot;</code> <var>X</var> <code>&quot;</code> as a subsequence
    </p>
    <p>
      <var>⟨valid delimiter⟩</var> ⩴ Any sequence of zero or more characters not including
      <code>&quot;</code>
    </p>
  </div>
  <p>
    Note that although valid delimiters look like strings when used, they
    do not interpret escape sequences inside of them.
  </p>
  <p>
    A raw string, when read, is a string. They are allowed wherever a regular
    Scheme string is allowed. The grammar of Scheme is modified so that the
    <var>⟨string⟩</var> production becomes
  </p>
  <div class="centered">
    <p>
      <var>⟨string⟩</var> ⩴ <code>&quot;</code> <var>⟨string element⟩</var><sup>*</sup>
      <code>&quot;</code>
      | <var>⟨raw string (X)⟩</var> for <var>X</var> satisfying <var>⟨valid delimiter⟩</var>
    </p>
  </div>
  <p>
    For example, raw strings are allowed in the <code>include</code> and
    <code>include-library-declaration</code> forms described in the <i>R<sup>7</sup>RS</i>.
  </p>
  <p>Examples:</p>
  <pre><code>#&quot;&quot;&quot;&quot; ; → &quot;&quot;
#&quot;&quot;a&quot;&quot; ; → &quot;a&quot;
#&quot;&quot;\&quot;&quot; ; → &quot;\\&quot;
#&quot;-&quot;&quot;&quot;-&quot; ; → &quot;\&quot;&quot;
#&quot;-&quot; &quot; &quot;-&quot; ; → &quot; \&quot; &quot;
#&quot;-&quot;#&quot;&quot;a&quot;&quot;&quot;-&quot; ; → &quot;#\&quot;\&quot;a\&quot;\&quot;&quot;
#&quot;-&quot;ends with \&quot;&quot;-&quot; ; → &quot;ends with \\\&quot;
#&quot;&quot;multiline
string&quot;&quot; ; → &quot;multiline\nstring&quot;
#&quot;&quot;
    no whitespace stripping&quot;&quot; ; → &quot;\n    no whitespace stripping&quot;
#&quot;&quot;\(?(\d{3})\D{0,3}(\d{3})\D{0,3}(\d{4})&quot;&quot;
  ; → &quot;\\(?(\\d{3})\\D{0,3}(\\d{3})\\D{0,3}(\\d{4})&quot;
  ; Example from SRFI 264</code></pre>
  <p>
    The following example shows how a raw string can be used to embed other
    syntaxes as a string. The syntax inside of the string is
    <a href="https://srfi.schemers.org/srfi-119">SRFI 119</a> wisp syntax.
  </p>
  <pre><code>#&quot;wisp-EOS&quot;
define: hello-name name
  string-append &quot;Hello,&quot; name &quot;!&quot;
&quot;wisp-EOS&quot;
; ⇒ &quot;\ndefine: hello-name name\n  string-append \&quot;Hello,\&quot; name \&quot;!\&quot;\n&quot;</code></pre>
  <p>
    One use of raw strings is in "docstring" documentation, where <code>&quot;</code> and <code>\</code> may be
    used to document strings. The following example is from Daphne Preston-Kendal:
  </p>
  <pre><code>(define (parse-url url-string)
  #&quot;&quot;Given a URL as a string, returns a Parsed-URL record with the
components of that URL.

(parse-url &quot;https://example.org/~smith/?record&quot;)
=&gt; #&lt;Parsed-URL protocol: &quot;https&quot; domain: &quot;example.org&quot;
                path: &quot;/~smith/&quot; query: &quot;?record&quot;&gt;&quot;&quot;
  ...)</code></pre>
  <h2>Implementation</h2>
  <p>
    A portable implementation is impossible in general. However, some
    implementations allow modifying the reader. The following code
    works with CHICKEN-5 and Guile 3.
  </p>
  <p>The last part doubles as a simple test suite.</p>
  <pre><code>(define (read-raw-string port)
  ;; This parser starts reading after `&quot;`.
  ;; In the given examples, the parser starts at the dot:
  ;;
  ;; #&quot;.&quot;asdf&quot;&quot;
  ;; #&quot;.--&quot;#&quot;()&quot;&quot;--&quot;
  (define (read-char* location)
    (let ((ch (read-char port)))
      (if (eof-object? ch)
          (error (list &quot;eof in raw string literal&quot; location))
          ch)))
  (define delimiter
    (do ((ch (read-char* 'delim) (read-char* 'delim))
         (acc '(#\&quot;) (cons ch acc)))
        ((char=? ch #\&quot;)
         (reverse (cons #\&quot; acc)))))
  (call-with-port (open-output-string)
    (lambda (out)
      (define (read-delimiter n rest-of-delimiter)
        (if (null? rest-of-delimiter)
            (get-output-string out)
            (let ((ch (read-char* 'check)))
              (if (char=? ch (car rest-of-delimiter))
                  (read-delimiter (+ n 1) (cdr rest-of-delimiter))
                  (do ((n n (- n 1))
                       (delimiter delimiter (cdr delimiter)))
                      ((zero? n) (read-raw ch))
                    (write-char (car delimiter) out))))))
      (define (read-raw ch)
        (if (char=? ch (car delimiter))
            (read-delimiter 1 (cdr delimiter))
            (begin (write-char ch out)
                   (read-raw (read-char* 'read)))))
      (read-raw (read-char* 'read)))))

(cond-expand
  (chicken (import (chicken read-syntax))
           (set-sharp-read-syntax! #\&quot; read-raw-string))
  (guile (read-hash-extend #\&quot;
                           (lambda (_ port)
                             (read-raw-string port))))
  (else (error &quot;your implementation is not supported&quot;)))

(define (test x y)
  (display (string=? x y)) (newline))

(test &quot;&quot; #&quot;&quot;&quot;&quot;)
(test &quot;a&quot; #&quot;&quot;a&quot;&quot;)
(test &quot;\\&quot; #&quot;&quot;\&quot;&quot;)
(test &quot;\&quot;&quot; #&quot;-&quot;&quot;&quot;-&quot;)
(test &quot;\\\&quot;&quot; #&quot;-&quot;\&quot;&quot;-&quot;)
(test &quot;#\&quot;()\&quot;&quot; #&quot;-&quot;#&quot;()&quot;&quot;-&quot;)
(test &quot;#\&quot;\&quot;a\&quot;\&quot;&quot; #&quot;-&quot;#&quot;&quot;a&quot;&quot;&quot;-&quot;)
(test &quot;ends with \\\&quot;&quot; #&quot;-&quot;ends with \&quot;&quot;-&quot;)
(test &quot;multiline\nstring&quot; #&quot;&quot;multiline
string&quot;&quot;)
(test &quot;\n    no whitespace stripping&quot; #&quot;&quot;
    no whitespace stripping&quot;&quot;)</code></pre>
  <p>
    A <a href="raw-strings.patch">patch</a> is available for Chez Scheme 10.3.0, and
    implements this SRFI.
  </p>
  <h2>Acknowledgments</h2>
  <p>
    The original
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2146.html"
      >C++ proposal</a
    >
    was written by Bemen Dawes. The last
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm"
      >C++ proposal</a
    >
    was written by Bemen Dawes and Lawrence Crowl. The raw string syntax was ratified in
    C++11.
  </p>
  <p>
    The choice of <code>#&quot;</code> was copied from Daphne Preston-Kendal. John Cowan
    suggested double quotes in place of balanced parentheses for raw strings
    and also gave some editorial advice.
  </p>
  <p>Thanks to the members of WG2 and others who discussed the issue.</p>
  <h2>Copyright</h2>
  <p>© 2025–2026 Peter McGoron</p>
  <p>
    Permission is hereby granted, free of charge, to any person obtaining a copy of this
    software and associated documentation files (the &quot;Software&quot;), to deal in
    the Software without restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
    Software, and to permit persons to whom the Software is furnished to do so, subject
    to the following conditions:
  </p>
  <p>
    The above copyright notice and this permission notice (including the next paragraph)
    shall be included in all copies or substantial portions of the Software.
  </p>
  <p>
    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
    A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  </p>
  </body>
</html>